# Description 
This demo is a simple example of how the command pattern works. It is made up of various panels each of which demonstrate different ways that you can use this design pattern and the architecture this package provides. While many of the examples in this scene could be implemented without the command pattern, it is intended to so the versatility of this pattern and its ability to separate the logic of functionality from its invocation in a variety of use cases. Note that the demo scene is intended to be viewed in the editor's game window in the free aspect display    
# Logger Panel
The panel in the top left is the simplest example included in this demo intended to showcase how this package and the command pattern works without any additional overhead. In the inspector for the parent object of the panel you will find two components, a LoggerCommandStream, and a LoggerCommandFactory. The LoggerCommandStream is the wrapper object for the invoker of the command pattern, the CommandStream object, discussed in the package README. It can act as a layer where you include information specific to your implementation of the command pattern that the inner invoker. In this example the method that exposes the "QueueCommand" method of the inner invoker only excepts LoggerCommand arguments, whereas the inner invoker will except any ICommand implementing object. This is also where we determine when to execute the queued commands. We could expose the TryExecuteNext method to the rest of the client to have more control of when exactly this happens; however, for simplicity in this demo (as well as the rest of them) we just execute commands in the wrapper components update method.  The LoggerCommandFactory simulates the client sending commands to the invoker through its wrapper. It will store your text entry and construct a logger command from it when one of the buttons is selected, which it will then send to the invoker. A LoggerCommand object is constructed from a string to log and an enum indicating wether it should be logged as a message, warning, or error. Once the command is executed, it prints the message in the desired manner. This demo is certainly overkill for a simple logger; however it hopefully clarifies what the command pattern is doing if it isn't already obvious.   
# Health Panel
This panel shows how you could use commands to modify some parameter of an entity in your game through an interface abstraction. It also demonstrates some of the ways you can extend CommandStream by reacting to command failures in its wrapper. 

## IHealth
This Interface acts as an abstraction for any object that would implement health. It has two properties it requires of its implementer, a get only property for Maximum health, as well as a property supporting both get and set for Health. It also has an event OnHealthChanged that should be invoked in the set of Health. We simulate an monobehaviour implementing this Interface through the HealthBar component. This component responds to the OnHealthChanged event by updating a UI element in the demo scene to show the new health value.

## ModifyHealthCommand
This is the command we use to modify the Health parameter. The receiver of this command is an object implementing IHealth, which is provided in its constructor along with an amount to modify it by. It implements IUndoable, which would return a command that modifies the IHealth object by the opposite magnitude. If you look at the code for this Command you will notice we cache the undo command in a field of the original command object upon the first invocation of GetUndoCommand. While this is not explicitly required by the IUndoable interface it is frequently a good idea to do so for a few reasons. Most broadly, this is good practice as it is more space efficient since we are not creating a new command every time we get the undo command. It also allows us to compare other commands to see if they are equal to the IUndoable's undo command. It is also IFailable and returns true for WouldFail if it would modify Health below zero or above MaximumHealth.

## CommandStream Wrapper (HealthCommandStream)
This class primarily just wraps a CommandStream in a Monobehaviour and exposes its QueueCommand method while executing commands in the update method. It simulates the client sending the invoker commands to execute through UI elements and a HealthCommandFactory that creates the appropriate ModifyHealthCommands based on those elements. One additional (and generally useful) piece of functionality this wrapper adds on top of the CommandStream is maintaining an undo stack. This is more useful when the command stream mixes commands that are IUndoable with commands that aren't. It also showcases one of the benefits of caching an IUndoable's undo command, as if we simply added each IUndoable executed to the undo stack we would enter a loop of continually undo-ing and redo-ing the same Command. Instead, we can store a reference to the last IUndoable we queued and undo command for and check if an executed command is equal to that undo command before adding it to the undo stack. One other extension worth commenting on here is how this wrapper responds to command failures. While the internal invoker doesn't know the implementation details of the commands its executing, in its wrapper we can check the type of a failed command and react to the failure accordingly. In this case we do so by queueing a new command that will modify the Health of the command's receiver to precisely zero or MaxHealth depending on whichever is appropriate for the command.

# Input Panel
Below the health panel is a more complicated example of using this package to respond to player inputs. This panel can be activated by toggling the switch beneath it. While active, you can move the player within the panel box through the WASD keys and fire projectiles by left or right clicking. These inputs can be rebound using the panel to the left as well, which also utilizes the command pattern and will be discussed next. 

## Input Types
there are 8 different types of inputs that are supported in this demo, represented in the InputType enum. First are the 4 directional movement inputs: up, down, left, and right, along with a sprint input that modifies the speed of movement. Then there are 2 fire inputs, fire and alt fire. And lastly is the undo movement, which causes the player to retrace their movement backwards until returning to their original position (or the oldest position recorded in the very unlikely situation over one million commands are executed in a single playmode session). 

## Player
When the demo is active this monobehaviour will check for key stroke's matching the KeyCode's in the InputCommandStream's InputKeybinds dictionary for each input type in its update method. If any of them are detected, it will queue the appropriate of the two command types in this demo into the InputCommandStream to be executed. This component has two fields modifiable in the inspector that will affect how it responds to movement input, its speed, which will determine fast the player moves, and the sprint factor, which the speed will be multiplied by if the sprint input is down while moving.

## MovePlayerCommand
The receiver of this command is the Player provided to it in its constructor. It moves its receiver in the (normalized) direction provided in its constructor with a given speed, also provided in the constructor. It implements IFailable and IUndoable, the implementation of the later of which should be obvious. It will return true for would fail if it would move the player outside of its bounding box (assigned in the inspector of the player). It can also be created by explicitly defining the vector to move the player by in the constructor, rather that provide a direction and speed and letting the command calculate the actual movement vector.

## SpawnProjectileCommand
This is an example of a command that creates its own receiver when it is invoked, making a new game object from the projectile visuals prefab stored in the player component, and attaching the projectile component to it. A player is also provided to this command, although it does not modify the player itself. Rather it uses the position of the player to determine where to spawn the projectile.

## Rebinding Inputs
The keys to queue each command can be rebound using the buttons on the panel to the left of the input demo. When one of these buttons is pressed a game object will be create that will listen for a keystroke. If the keystroke detected is not currently used for a different input command, it will change the key for the selected input type to the detected key. Currently the keybindings are reset upon leaving playmode; however, this could be circumvented using a scriptable object or json to store the changes and reload them upon reentering playmode; however, that is beyond the scope of this demo. This panel also works using a command system.

### RebindButtonManager
This object stores each of the rebind buttons and sets their text and the delegate's invoked when they are pressed in its start method. It also maintains a CommandStream the commands to rebind inputs are queued into. These could be queued into InputCommandStream instead; however due to the complicated nature of RebindKeyCommands this would be more difficult. Very importantly you will notice we store a reference to the previous RebindKeyCommand, and a bool named "rebindTaskRunning." The importance of these field will be more clear after discussing how RebindKeyCommand's work

### RebindKeyCommand
This command is an example of how we can significantly increase the complexity of our commands functionality using async Commands and events. If you look at the code for RebindKeyCommand you will notice its Execute method invokes a separate method ExecuteAsync(), and stores its return value in a public field. This is because due to the nature of asynchronous operations the execute method will finish before we have fully completed rebinding the key. To illustrate this - this demo will print a few debug log messages when rebinding a key. One will be printed as soon as ExecuteAsync() is invoked, another when CommandStream.TryExecuteNext() returns true, and the last after the key has been rebound (at the end of ExecuteAsync()). You will notice the first log to be printed is the log for the async task starting, then the log for TryExecuteNext() returning true, and lastly (after you enter a valid key stroke) the log for the async task completing. This is due to how async methods are executed. Once we reach the point where the ExecuteAsync() is waiting for a valid input, the main thread (TryExecuteNext() -> Execute()) will return, with the asynchronous thread (ExecuteAsync()) continuing to run in the background. Because of this, when we invoke the Execute method of a RebindKeyCommand, we store the return value of ExecuteAsync() (the Task that is being preformed asynchronously, more information [here](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-6.0)) in the public CommandTask field. This field will allow us to access important information about wether we have finished rebinding the key or not.

Notably - it would be possible for us to make the Execute() method async and move all of the logic from ExecuteAsync() into the Execute override, making a method async does not change its signature; however, doing this would be much more error prone. We would no longer have access to the important information we are storing in the RebindKeyCommand's commandTask field, such as (and most importantly) if the task has completed. For more information on way methods with "async void" are generally best avoid see the [C# documentation](https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming) on async best practices.

Now, the use reason we are storing the previous command and what the rebindTaskRunning bool tells us should be more clear. If the previous command is null, then we clearly have no task running, otherwise we access the previous command's commandTask field and verify it has completed. If a task is running we ignore any further press of the rebind buttons to prevent another RebindKeyCommand from being queued until this one has completed, and as a failsafe if our previous command is still running its async task we skip the TryExecuteNext() step of update, so that if another RebindKeyCommand did somehow get queued we can be doubly certain we wont have two RebindKeyCommand's running their async task at the same time.