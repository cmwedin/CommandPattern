# Description 
This demo is a simple example of how the command pattern works. It is made up of various panels each of which demonstrate different ways that you can use this design pattern and the architecture this package provides. While many of the examples in this scene could be implemented without the command pattern, it is intended to so the versatility of this pattern and its ability to separate the logic of functionality from its invocation in a variety of use cases.   

# Health Panel
This panel shows how you could use commands to modify some parameter of an entity in your game through an interface abstraction. It also demonstrates some of the ways you can extend CommandStream by reacting to command failures in its wrapper. 

## IHealth
This Interface acts as an abstraction for any object that would implement health. It has two properties it requires of its implementer, a get only property for Maximum health, as well as a property supporting both get and set for Health. It also has an event OnHealthChanged that should be invoked in the set of Health. We simulate an monobehaviour implementing this Interface through the HealthBar component. This component responds to the OnHealthChanged event by updating a UI element in the demo scene to show the new health value.

## ModifyHealthCommand
This is the command we use to modify the Health parameter. The receiver of this command is an object implementing IHealth, which is provided in its constructor along with an amount to modify it by. It implements IUndoable, which would return a command that modifies the IHealth object by the opposite magnitude. If you look at the code for this Command you will notice we cache the undo command in a field of the original command object upon the first invocation of GetUndoCommand. While this is not explicitly required by the IUndoable interface it is frequently a good idea to do so for a few reasons. Most broadly, this is good practice as it is more space efficient since we are not creating a new command every time we get the undo command. It also allows us to compare other commands to see if they are equal to the IUndoable's undo command. It is also IFailable and returns true for WouldFail if it would modify Health below zero or above MaximumHealth.

## CommandStream Wrapper (HealthCommandStream)
This class primarily just wraps a CommandStream in a Monobehaviour and exposes its QueueCommand method while executing commands in the update method. It simulates the client sending the invoker commands to execute through UI elements and a HealthCommandFactory that creates the appropriate ModifyHealthCommands based on those elements. One additional (and generally useful) piece of functionality this wrapper adds on top of the CommandStream is maintaining an undo stack. This is more useful when the command stream mixes commands that are IUndoable with commands that aren't. It also showcases one of the benefits of caching an IUndoable's undo command, as if we simply added each IUndoable executed to the undo stack we would enter a loop of continually undo-ing and redo-ing the same Command. Instead, we can store a reference to the last IUndoable we queued and undo command for and check if an executed command is equal to that undo command before adding it to the undo stack. One other extension worth commenting on here is how this wrapper responds to command failures. While the internal invoker doesn't know the implementation details of the commands its executing, in its wrapper we can check the type of a failed command and react to the failure accordingly. In this case we do so by queueing a new command that will modify the Health of the command's receiver to precisely zero or MaxHealth depending on whichever is appropriate for the command.   