# Description 
This demo is a simple example of how the command pattern works. It is made up of various panels each of which demonstrate different ways that you can use this design pattern and the architecture this package provides. While many of the examples in this scene could be implemented without the command pattern, it is intended to so the versatility of this pattern and its ability to separate the logic of functionality from its invocation in a variety of use cases. We will explain the demos here in order from least to most complicated. Note that the demo scene is intended to be viewed in the editor's game window in the free aspect display, using a large/maximized game window may leave empty space on the sides.    
# Logger Panel
The panel in the top left is the simplest example included in this demo intended to showcase how this package and the command pattern works without any additional overhead. In the inspector for the parent object of the panel you will find two components, a LoggerCommandStream, and a LoggerCommandFactory. The LoggerCommandStream is the wrapper object for the invoker of the command pattern, the CommandStream object, discussed in the package README. It can act as a layer where you include information specific to your implementation of the command pattern that the inner invoker. In this example the method that exposes the "QueueCommand" method of the inner invoker only excepts LoggerCommand arguments, whereas the inner invoker will except any ICommand implementing object. This is also where we determine when to execute the queued commands. We could expose the TryExecuteNext method to the rest of the client to have more control of when exactly this happens; however, for simplicity in this demo (as well as the rest of them) we just execute commands in the wrapper components update method.  The LoggerCommandFactory simulates the client sending commands to the invoker through its wrapper. It will store your text entry and construct a logger command from it when one of the buttons is selected, which it will then send to the invoker. A LoggerCommand object is constructed from a string to log and an enum indicating wether it should be logged as a message, warning, or error. Once the command is executed, it prints the message in the desired manner. This demo is certainly overkill for a simple logger; however it hopefully clarifies what the command pattern is doing if it isn't already obvious.   
# Health Panel
This panel shows how you could use commands to modify some parameter of an entity in your game through an interface abstraction. It also demonstrates some of the ways you can extend CommandStream by reacting to command failures in its wrapper. 

## IHealth
This Interface acts as an abstraction for any object that would implement health. It has two properties it requires of its implementer, a get only property for Maximum health, as well as a property supporting both get and set for Health. It also has an event OnHealthChanged that should be invoked in the set of Health. We simulate an monobehaviour implementing this Interface through the HealthBar component. This component responds to the OnHealthChanged event by updating a UI element in the demo scene to show the new health value.

## ModifyHealthCommand
This is the command we use to modify the Health parameter. The receiver of this command is an object implementing IHealth, which is provided in its constructor along with an amount to modify it by. It implements IUndoable, which would return a command that modifies the IHealth object by the opposite magnitude. If you look at the code for this Command you will notice we cache the undo command in a field of the original command object upon the first invocation of GetUndoCommand. While this is not explicitly required by the IUndoable interface it is frequently a good idea to do so for a few reasons. Most broadly, this is good practice as it is more space efficient since we are not creating a new command every time we get the undo command. It also allows us to compare other commands to see if they are equal to the IUndoable's undo command. It is also IFailable and returns true for WouldFail if it would modify Health below zero or above MaximumHealth.

## CommandStream Wrapper (HealthCommandStream)
This class primarily just wraps a CommandStream in a Monobehaviour and exposes its QueueCommand method while executing commands in the update method. It simulates the client sending the invoker commands to execute through UI elements and a HealthCommandFactory that creates the appropriate ModifyHealthCommands based on those elements. One additional (and generally useful) piece of functionality this wrapper adds on top of the CommandStream is maintaining an undo stack. This is more useful when the command stream mixes commands that are IUndoable with commands that aren't. It also showcases one of the benefits of caching an IUndoable's undo command, as if we simply added each IUndoable executed to the undo stack we would enter a loop of continually undo-ing and redo-ing the same Command. Instead, we can store a reference to the last IUndoable we queued and undo command for and check if an executed command is equal to that undo command before adding it to the undo stack. One other extension worth commenting on here is how this wrapper responds to command failures. While the internal invoker doesn't know the implementation details of the commands its executing, in its wrapper we can check the type of a failed command and react to the failure accordingly. In this case we do so by queueing a new command that will modify the Health of the command's receiver to precisely zero or MaxHealth depending on whichever is appropriate for the command.
# Simple Async Panel
Moving on to some of the more complex panel's, we have first a demonstration of one of the more advanced command types, AsyncCommands. These commands are created by inheriting from the AsyncCommand class rather than the normal Command class. To illustrate how AsyncCommand work better, the commands in this panel are very simple and just wait for a certain number of seconds before completing. To see how they work, open the console window in the Unity Editor, and then in play-mode click on one of the "run" buttons on this panel. You will notice three messages printing in the console. The first is from the command and indicates how long of wait it will preform, the second is from the CommandStream wrapper and indicates that TryExecuteNext as returned, and the third indicates that the wait has completed. If you aren't familiar with asynchronous programming you may be surprised by this, the we have a return value from TryExecuteNext, but the command isn't done executing yet! This is the strength of asynchronous methods, to see whats happening better lets open up the WaitForSecondsCommand class and take a closer look at what is happening.
## WaitForSecondsCommand & AsyncCommand
Looking through the methods in this class one of the first things that might jump out to you is that **there is no Execute method in this class**, instead the logic of the command is implemented in a separate method `ExecuteAsync`, which unlike the standard `Execute` method has a return value of Task (you also notice that despite having a return value the method never actually returns anything, more on that latter), and has the additional keyword async. In fact, when you inherit from AsyncCommand you are explicitly prevented from overriding, and the Execute method within AsyncCommand is sealed is the final override in this chain of inheritance. Lets take a look at the base class of AsyncCommand to see why this is the case.

Taking a look at the AsyncCommand implementation of `Execute`, you can see that it does a few things. We will focus on the two methods it invokes first and circle back to the bookkeeping it preforms later. The first method it invokes is the ExecuteAsync, where concrete implementation of AsyncCommand place their logic. It stores the return value of this method in the CommandTask property. But recall, we never return anything from ExecuteAsync in our implementation. What going on here? Well at this point we have set the stage enough to talk about what an async method actually means. We you declare a method as async, that there is some portion of it that needs to wait on something else before it can be completed. Rather than block the main thread from executing while it waits, upon reaching an "await" statement, the method will return a task representing the rest of its execution, than resume that task on a separate thread once its done executing.

Returning to the ExecuteAsync method of WaitForSecondsCommand we can see that this method prints the first debug log we saw in the console, then it enters a for loop, each iteration increasing i by the time-step, and leaves once i is greater then the total wait in milliseconds. At the end of each iteration of the loop is the line `await Task.Delay(timeStep);`. As soon as we reach this line for the first time, control of the main thread will be returned to the invoker of the ExecuteAsync, along with the task for its completion, which will resume on a separate thread each time the time-step has elapsed. Putting this all together, when the CommandStream has its TryExecuteNext method invoked, it will invoke the Execute method of WaitForSecondsCommand, which is defined by its base AsyncCommand class. This method is check if the CommandTask has already had its value assigned, and if it has check if it is still running. If so, it will throw an exception that is handled by the CommandStream. Otherwise, it will invoke ExecuteAsync, which will run to the end of the first iteration of the for loop before returning its task to be stored in the CommandTask field, and invoke another async method, `InvokeWhenTaskComplete`. Looking at this method we see it await's CommandTask before invoking one of three events depending on how it finished (the 3 ways an AsyncCommand can finish its task are successfully, by being cancelled, or by the task throwing an exception). At this point, the `Execute` method completes, and control returns to `TryExecuteNext`, this method sees that it just executed a IAsyncCommand, preforms some bookkeeping (more information about this is in the [package README](../../README.md)), and then returns the ExecuteCode "AwaitingCompletion." Control has now been returned to the `Update` method of the CommandStream's wrapper, which prints the second debug log we saw. While all of this is happening, the CommandTask is still running on a separate thread. Each time the time-step elapses, it resumes its execution and moves on to the next iteration of the loop. It reports its new progress, checks if it has been canceled (more on this in a moment), and then suspends the task for a time-step again. Once the total desired number of time-steps has elapsed, the method breaks out of the loop, prints the third debug log we saw, and finally we reach the end of the method. Rather than returning control to the invoker (since the main thread has long since returned to the CommandStream's wrapper by now), this causes CommandTask to be marked as complete. This in turn causes the invokeCompletionEventTask, which has been waiting for CommandTask to complete all this time, to resume, and the InvokeWhenTaskComplete method to finish by raising the OnTaskComplete event.

On the right underneath this panel are some setting you can adjust to visualize how the different changes affect all of this. You can try pressing multiple "Run" buttons at once and see how the update cycle of the CommandStream wrapper continues to execute newly queued commands while the previous ones run in the background. You can also increase the time-step to visually see how the tasks stop and start as the time-steps go by. Try running a short WaitForSecondsCommand immediately after a long one and notice how even though the long one was started first the short one records its final debug log before the long one does.

## AsyncCommand Cancellation 
Lets circle back to the command cancellation now, as this is important to understand when implementing your own AsyncCommands. You may have already experimented with the cancellation button. If you did, you probably noticed how it takes a moment for the cancellation to actually occur, especially if you experimented with longer time-steps. This is because cancelling asynchronous method doesn't happen automatically, but needs to be deliberately implemented. To understand this, lets zoom out and look at how canceling async tasks work's in general.

Canceling a task first involves creating a CancellationTokenSource object. This object, as its name implies, has a CancellationToken as well. The CancellationTokenSource is used to indicate that a task should be cancelled. The task, than uses the CancellationToken to determine if the CancellationTokenSource has been told that it should be cancelled. When a CommandStream see's that it has executed a command implementing IAsyncCommand, it will create a new CancellationTokenSource as assign the source's token to the CancellationToken property of the IAsyncCommand. This CancellationTokenSource can than be retrieved using the CommandStream's `GetRunningTaskCTS` method. When a CTS is done being used it is important to dispose of it lest it lead to a memory leak (as there are un-managed resources associated with the CTS that will not be cleaned up in garbage collection), this is also handled by the CommandStream for you. When you want to indicate a task should be canceled, you do so by using the `Cancel` method of its token's source. You do not need to retrieve the CTS from the CommandStream every time you want to do this, it as a `CancelRunningTask` method to do this for you (both `GetRunningTaskCTS` and `CancelRunningTask` can be invoked using either the task itself or the AsyncCommand that created it as an argument).

But remember, all this is doing is indicating to the token that the task should be canceled. You need to respond to that indication withing your ExecuteAsync method, otherwise using the CancelRunningTask method will do nothing. In WaitForSecondsCommand we do this in the conditional:
    if (CancellationToken.IsCancellationRequested) {
        Debug.Log($"{millisecondsToWait} ms wait cancelled after {i} milliseconds");
        CancellationToken.ThrowIfCancellationRequested();
    }

We could also simply invoke `CancellationToken.ThrowIfCancellationRequested();` as this will do nothing unless `CancellationToken.IsCancellationRequested` is true, however there is often clean-up you will want to do before canceling the task in order for it to cancel gracefully. This is why it takes a moment for cancellation to occur. If you cancel while the Task is await'ing the time time, it will still finish that await and not cancel until its next loop after it updates its progress. You may be wondering, what happens in the first loop before the CommandStream has had the opportunity to create the CancellationTokenSource? How are we able to access members of the CancellationToken before its value has been assigned? The reason for that is the type CancellationToken is actually a value-type struct, not a reference-type class. This means that before CancellationToken has been assigned it has the value CancellationToken.None, which is also what the CommandStream will set its value back to after it dispose's between executions. 
# Input Panel
Below the health panel is a more complicated example of using this package to respond to player inputs. This panel can be activated by toggling the switch beneath it. While active, you can move the player within the panel box through the WASD keys and fire projectiles by left or right clicking. These inputs can be rebound using the panel to the left as well, which also utilizes the command pattern and will be discussed next. 

## Input Types
there are 8 different types of inputs that are supported in this demo, represented in the InputType enum. First are the 4 directional movement inputs: up, down, left, and right, along with a sprint input that modifies the speed of movement. Then there are 2 fire inputs, fire and alt fire. And lastly is the undo movement, which causes the player to retrace their movement backwards until returning to their original position (or the oldest position recorded in the very unlikely situation over one million commands are executed in a single playmode session). 

## Player
When the demo is active this monobehaviour will check for key stroke's matching the KeyCode's in the InputCommandStream's InputKeybinds dictionary for each input type in its update method. If any of them are detected, it will queue the appropriate of the two command types in this demo into the InputCommandStream to be executed. This component has two fields modifiable in the inspector that will affect how it responds to movement input, its speed, which will determine fast the player moves, and the sprint factor, which the speed will be multiplied by if the sprint input is down while moving.

## MovePlayerCommand
The receiver of this command is the Player provided to it in its constructor. It moves its receiver in the (normalized) direction provided in its constructor with a given speed, also provided in the constructor. It implements IFailable and IUndoable, the implementation of the later of which should be obvious. It will return true for would fail if it would move the player outside of its bounding box (assigned in the inspector of the player). It can also be created by explicitly defining the vector to move the player by in the constructor, rather that provide a direction and speed and letting the command calculate the actual movement vector.

## SpawnProjectileCommand
This is an example of a command that creates its own receiver when it is invoked, making a new game object from the projectile visuals prefab stored in the player component, and attaching the projectile component to it. A player is also provided to this command, although it does not modify the player itself. Rather it uses the position of the player to determine where to spawn the projectile.

## Rebinding Inputs
The keys to queue each command can be rebound using the buttons on the panel to the left of the input demo. When one of these buttons is pressed a game object will be create that will listen for a keystroke. If the keystroke detected is not currently used for a different input command, it will change the key for the selected input type to the detected key. Currently the keybindings are reset upon leaving playmode; however, this could be circumvented using a scriptable object or json to store the changes and reload them upon reentering playmode; however, that is beyond the scope of this demo. This panel also works using a command system.

### RebindButtonManager
This object stores each of the rebind buttons and sets their text and the delegate's invoked when they are pressed in its start method. It also maintains a CommandStream the commands to rebind inputs are queued into. These could be queued into InputCommandStream instead; however due to the complicated nature of RebindKeyCommands this would be more difficult. Very importantly you will notice we store a reference to the previous RebindKeyCommand, and a bool named "rebindTaskRunning." The importance of these field will be more clear after discussing how RebindKeyCommand's work

### RebindKeyCommand
This command is an example of how we can significantly increase the complexity of our commands functionality using async Commands and events. If you look at the code for RebindKeyCommand you will notice its Execute method invokes a separate method ExecuteAsync(), and stores its return value in a public field. This is because due to the nature of asynchronous operations the execute method will finish before we have fully completed rebinding the key. To illustrate this - this demo will print a few debug log messages when rebinding a key. One will be printed as soon as ExecuteAsync() is invoked, another when CommandStream.TryExecuteNext() returns true, and the last after the key has been rebound (at the end of ExecuteAsync()). You will notice the first log to be printed is the log for the async task starting, then the log for TryExecuteNext() returning true, and lastly (after you enter a valid key stroke) the log for the async task completing. This is due to how async methods are executed. Once we reach the point where the ExecuteAsync() is waiting for a valid input, the main thread (TryExecuteNext() -> Execute()) will return, with the asynchronous thread (ExecuteAsync()) continuing to run in the background. Because of this, when we invoke the Execute method of a RebindKeyCommand, we store the return value of ExecuteAsync() (the Task that is being preformed asynchronously, more information [here](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-6.0)) in the public CommandTask field. This field will allow us to access important information about wether we have finished rebinding the key or not.

Notably - it would be possible for us to make the Execute() method async and move all of the logic from ExecuteAsync() into the Execute override, making a method async does not change its signature; however, doing this would be much more error prone. We would no longer have access to the important information we are storing in the RebindKeyCommand's commandTask field, such as (and most importantly) if the task has completed. For more information on way methods with "async void" are generally best avoid see the [C# documentation](https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming) on async best practices.

Now, the use reason we are storing the previous command and what the rebindTaskRunning bool tells us should be more clear. If the previous command is null, then we clearly have no task running, otherwise we access the previous command's commandTask field and verify it has completed. If a task is running we ignore any further press of the rebind buttons to prevent another RebindKeyCommand from being queued until this one has completed, and as a failsafe if our previous command is still running its async task we skip the TryExecuteNext() step of update, so that if another RebindKeyCommand did somehow get queued we can be doubly certain we wont have two RebindKeyCommand's running their async task at the same time.